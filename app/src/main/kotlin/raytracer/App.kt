/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package raytracer

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.runBlocking
import me.tongfei.progressbar.ProgressBar
import java.io.File
import kotlin.random.Random

fun randomMaterial(): Material {
    val p = Random.nextDouble()
    return when {
        p < 0.8 -> Lambertian(Color.random() * Color.random())
        p < 0.95 -> Metal(Color.random(0.5, 1.0), Random.nextDouble(0.0, 0.5))
        else -> Dielectric(1.5)
    }
}

fun randomScene(): Hittable {
    val groundMaterial = Lambertian(Color(0.5, 0.5, 0.5))
    val objects: List<Hittable> = mutableListOf<Hittable>().apply {
        add(Sphere(Point3d(0.0, -1000.0, 0.0), 1000.0, groundMaterial))
        add(Sphere(Point3d(0.0, 1.0, 0.0), 1.0, Dielectric(1.5)))
        add(Sphere(Point3d(-4.0, 1.0, 0.0), 1.0, Lambertian(Color(0.4, 0.2, 0.1))))
        add(Sphere(Point3d(4.0, 1.0, 0.0), 1.0, Metal(Color(0.7, 0.6, 0.5), 0.0)))
        for (a in -11 until 11) {
            for (b in -11 until 11) {
                val center = Point3d(a + 0.9 * Random.nextDouble(), 0.2, b + 0.9 * Random.nextDouble())
                val material = randomMaterial()
                val hittable = Sphere(center, 0.2, material)
                add(hittable)
            }
        }
    }
    return HittableList(objects)
}

fun rayColor(ray: Ray, world: Hittable, depth: Int): Color {
    if (depth <= 0) {
        return Color.ZERO
    }
    val hit = world.hit(ray, Double.MIN_VALUE, Double.POSITIVE_INFINITY)
    if (hit != null) {
        val scattered = hit.scatter(ray)
        if (scattered != null) {
            return scattered.attenuation * rayColor(scattered.ray, world, depth - 1)
        }
        return Color.ZERO
    }
    val unitDirection = ray.direction.unit()
    val t = 0.5 * (unitDirection.y + 1.0)
    return Color.ONE * (1.0 - t) + Color(0.5, 0.7, 1.0) * t
}

fun main() {
    val aspectRatio = 3.0 / 2.0
    val imageWidth = 200
    val imageHeight = (imageWidth / aspectRatio).toInt()
    val samplesPerPixel = 50
    val maxDepth = 50

    // World
    val world = randomScene()

    // Camera
    val lookFrom = Point3d(13.0, 2.0, 3.0)
    val lookAt = Point3d(0.0, 0.0, 0.0)
    val vup = Vec3d(0.0, 1.0, 0.0)
    val verticalFieldOfViewInDegrees = 20.0
    val aperture = 0.1
    val distToFocus = 10.0
    val camera = Camera(
        lookFrom, lookAt, vup, verticalFieldOfViewInDegrees,
        aspectRatio,
        aperture,
        distToFocus,
    )

    // Render

    File("image.ppm").printWriter().use { out ->
        out.print("P3\n$imageWidth $imageHeight\n255\n")

        ProgressBar("Scanlines", (imageHeight * imageWidth).toLong()).use { bar ->
            val pixels = (imageHeight - 1).downTo(0).flatMap { j ->
                (0 until imageWidth).map { i -> Pair(j, i) }
            }
            runBlocking {
                val pixelColors = pixels.map { (j, i) ->
                    async(Dispatchers.Default) {
                        (0 until samplesPerPixel).fold(Color.ZERO) { acc, _ ->
                            val u = (i.toDouble() + Random.nextDouble()) / (imageWidth - 1)
                            val v = (j.toDouble() + Random.nextDouble()) / (imageHeight - 1)
                            val r = camera.ray(u, v)
                            acc + rayColor(r, world, maxDepth)
                        }
                    }
                }
                for (pixelColor in pixelColors) {
                    bar.step()
                    out.println(pixelColor.await().ppmString(samplesPerPixel))
                }
            }
        }
    }
}
