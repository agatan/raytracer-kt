/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package raytracer

import me.tongfei.progressbar.ProgressBar
import java.io.File
import kotlin.math.sqrt
import kotlin.random.Random

fun sphereHitTimestep(center: Point3d, radius: Double, ray: Ray): Double? {
    // t^2 * b * b + 2tb * (A - C) + (A - C) * (A - C) - r^2 = 0
    //   t: timestep
    //   A: ray origin
    //   b: ray direction
    //   C: center of the sphere
    //   r: radius of the sphere
    val oc = ray.origin - center
    val a = ray.direction.l2norm()
    val halfB = oc.dot(ray.direction)
    val c = oc.l2norm() - radius * radius
    val discriminant = halfB * halfB - a * c
    if (discriminant < 0) {
        return null
    }
    return (-halfB - sqrt(discriminant)) / a
}

fun rayColor(ray: Ray, world: Hittable, depth: Int): Color {
    if (depth <= 0) {
        return Color.ZERO
    }
    val hit = world.hit(ray, Double.MIN_VALUE, Double.POSITIVE_INFINITY)
    if (hit != null) {
        val target = hit.p + Vec3d.randomInHemisphere(hit.normal)
        return rayColor(Ray(hit.p, target - hit.p), world, depth - 1) * 0.5
    }
    val unitDirection = ray.direction.unit()
    val t = 0.5 * (unitDirection.y + 1.0)
    return Color.ONE * (1.0 - t) + Color(0.5, 0.7, 1.0) * t
}

fun main() {
    val aspectRatio = 16.0 / 9.0
    val imageWidth = 400
    val imageHeight = (imageWidth / aspectRatio).toInt()
    val samplesPerPixel = 100
    val maxDepth = 50

    // World
    val world = HittableList(
        Sphere(Point3d(0.0, 0.0, -1.0), 0.5),
        Sphere(Point3d(0.0, -100.5, -1.0), 100.0),
    )

    // Camera
    val camera = Camera()

    // Render

    File("image.ppm").printWriter().use { out ->
        out.print("P3\n$imageWidth $imageHeight\n255\n")

        ProgressBar("Scanlines", imageHeight.toLong()).use { bar ->
            for (j in (imageHeight - 1) downTo 0) {
                bar.step()
                for (i in 0 until imageWidth) {
                    val pixelColor = (0 until samplesPerPixel).fold(Color.ZERO) { acc, _ ->
                        val u = (i.toDouble() + Random.nextDouble()) / (imageWidth - 1)
                        val v = (j.toDouble() + Random.nextDouble()) / (imageHeight - 1)
                        val r = camera.ray(u, v)
                        acc + rayColor(r, world, maxDepth)
                    }
                    out.println(pixelColor.ppmString(samplesPerPixel))
                }
            }
        }
    }
}
