/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package raytracer

import me.tongfei.progressbar.ProgressBar
import java.io.File
import kotlin.random.Random

fun rayColor(ray: Ray, world: Hittable, depth: Int): Color {
    if (depth <= 0) {
        return Color.ZERO
    }
    val hit = world.hit(ray, Double.MIN_VALUE, Double.POSITIVE_INFINITY)
    if (hit != null) {
        val scattered = hit.scatter(ray)
        if (scattered != null) {
            return scattered.attenuation * rayColor(scattered.ray, world, depth - 1)
        }
        return Color.ZERO
    }
    val unitDirection = ray.direction.unit()
    val t = 0.5 * (unitDirection.y + 1.0)
    return Color.ONE * (1.0 - t) + Color(0.5, 0.7, 1.0) * t
}

fun main() {
    val aspectRatio = 16.0 / 9.0
    val imageWidth = 400
    val imageHeight = (imageWidth / aspectRatio).toInt()
    val samplesPerPixel = 100
    val maxDepth = 50

    // World
    val materialGround = Lambertian(Color(0.8, 0.8, 0.0))
    val materialCenter = Lambertian(Color(0.7, 0.3, 0.3))
    val materialLeft = Metal(Color(0.8, 0.8, 0.8), 0.3)
    val materialRight = Metal(Color(0.8, 0.6, 0.2), 1.0)
    val world = HittableList(
        Sphere(Point3d(0.0, -100.5, -1.0), 100.0, materialGround),
        Sphere(Point3d(0.0, 0.0, -1.0), 0.5, materialCenter),
        Sphere(Point3d(-1.0, 0.0, -1.0), 0.5, materialLeft),
        Sphere(Point3d(1.0, 0.0, -1.0), 0.5, materialRight),
    )

    // Camera
    val camera = Camera()

    // Render

    File("image.ppm").printWriter().use { out ->
        out.print("P3\n$imageWidth $imageHeight\n255\n")

        ProgressBar("Scanlines", imageHeight.toLong()).use { bar ->
            for (j in (imageHeight - 1) downTo 0) {
                bar.step()
                for (i in 0 until imageWidth) {
                    val pixelColor = (0 until samplesPerPixel).fold(Color.ZERO) { acc, _ ->
                        val u = (i.toDouble() + Random.nextDouble()) / (imageWidth - 1)
                        val v = (j.toDouble() + Random.nextDouble()) / (imageHeight - 1)
                        val r = camera.ray(u, v)
                        acc + rayColor(r, world, maxDepth)
                    }
                    out.println(pixelColor.ppmString(samplesPerPixel))
                }
            }
        }
    }
}
